<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../css/pmag.css" type="text/css" />
</head>
<body>
<div id="header_wrap">
   <h1><a href="https://www.facebook.com/groups/programmerMagazine">程式人雜誌</a> <sub> --  <a href="https://dl.dropbox.com/u/101584453/pmag/201308/htm/home.html">2013 年 8 月號</a> (開放公益出版品)</sub></h1>
</div>
<div id="content">
<div id="TOC">
<ul>
<li><a href="#x86-machine-code-初探-0---base-register-address-mode-作者descent-sung">x86 machine code 初探 (0) - base register address mode (作者：Descent Sung)</a></li>
</ul>
</div>
<h2 id="x86-machine-code-初探-0---base-register-address-mode-作者descent-sung"><a href="#x86-machine-code-初探-0---base-register-address-mode-作者descent-sung">x86 machine code 初探 (0) - base register address mode (作者：Descent Sung)</a></h2>
<p>我從來沒想過我會學習 machine code, 而且 x86 machine code 實在太複雜, 花了很多心力才有點進展。本來直接拿起 intel 那令人害怕的手冊硬 K, 果然不行, 有看沒有懂, 再看 ref 3, 還是看不懂。而在閱讀了 ref 1, 2 後, 我如獲至寶, 看懂之後再翻閱 ref 3, 終於有了進展。當能看懂時, 心中的興奮之情, 恐怕只有和我一樣在 machine code 裡頭掙扎的同好才能理解。</p>
<p>不過 x86 machine code 實在太複雜, 我並沒能搞懂所有格式。</p>
<p>為什麼要研究 machine code 呢？因為要改寫執行檔的位址, 做類似 dynamic loader/linker 的事情, 會看這篇文章的朋友, 難道你對於 dynamic loader/linker 的原理沒有興趣嗎？不會想個方法來實驗這件事情嗎？Binary Hacks--駭客秘傳技巧一百招 #72 就在談這個。</p>
<p>讓我們從 intel memory address 開始。intel 著名的 segmentation memory address, 將記憶體位址分為 segment part, offset part, 本文章重點擺在 offset part。而台灣翻譯的基底/索引定址法 (中國的翻譯則是 ...) 則為 base/index。</p>
<p>offset part 有三個欄位:</p>
<ol style="list-style-type: decimal">
<li>base register</li>
<li>index register multiplied 1, 2, 4, 8 (1, 2, 4, 8 被稱為 scale factor)</li>
<li>displacement</li>
</ol>
<p>base + index * scale + displacement = offset part</p>
<p>ex:</p>
<p>at&amp;t syntax add 0x12345678(%eax, %esi, 4), %esi intel syntax add esi, [eax+esi*4+0x12345678]</p>
<p>本篇文章大量參考 Programming THE 80386 (instruction encoding - p59):</p>
<div class="figure">
<img src="../img/x86_book.JPG" />
</div>
<p>這是 1987 年的書 (我寫這篇文章的時間是 20130612), 在電腦界這麼快速更新的時代, 照理說應該是過期的書籍, 不過由於相容性的緣故, 裡頭提到的東西到現在都還是可以用的, 而且簡單不少 (也沒有 64 bit mode), intel 手冊已經變得又厚又硬難以閱讀, 而這本書講的比較好理解。有些術語和最新的 intel 手冊有些不同, 不過不影響理解。</p>
<p>之前在閱讀 <a href="http://descent-incoming.blogspot.tw/2010/11/dropbox-for-linux.html">IBM 80X86 組合語言實務</a> 被其複雜的定址模式搞得我好亂, 現在一次把它搞懂。這些複雜的 address mode 是針對 offset part 而來, 大概就是 base register 和 index register mode 這兩種比較複雜。而 16 bit 和 32 bit 又有點不同, 64 bit 沒研究, 就不提了。</p>
<p>16 bit 和 32 bit 可用來當 base/index register 的暫存器有些不同。為什麼呢？讀懂 machine code 就可以回答這問題。</p>
<p>x86 machine code 順序, 後面的數字是 byte 數目:</p>
<ol style="list-style-type: decimal">
<li>prefix 0-4</li>
<li>opcode 1-2</li>
<li>modrm 0-2</li>
<li>displacement 0-4</li>
<li>immediate 0-4</li>
</ol>
<p>這是這本書的解釋, 和目前的 intel 手冊有些不同, 目前的 intel 手冊把 modrm 分為 modrm + sib, 不過沒關係, 原則都是一樣的。我建議先看過 ref 1, ref 2 再看這篇, 如果真的沒時間至少也要看過 ref 2, 因為他們提到的東西, 我不會特別說明, 請花點時間看, 若你真想理解這玩意, 應該有覺悟要佔去你不少休閒時間。</p>
<p>檔案：address_mode.S</p>
<pre><code>1 # practice x86 machine code
2 .code16
3 #.code32
4 .text
5 .global begin
6 begin:
7   add (%bx), %ax</code></pre>
<p>看看 L7 的組語, 這使用了 base register address mode。</p>
<pre><code>objdump -d -m i8086 address_mode.elf

1 descent@w-linux:x86_machine_code$ objdump -d -m i8086 address_mode.elf 
2 
3 address_mode.elf:     file format elf32-i386
4 
5 
6 Disassembly of section .text:
7 
8 00000100 &lt;_text&gt;:
9  100:   03 07                   add    (%bx),%ax</code></pre>
<p>由於 intel cpu 有 16/32/64 bit mode, 所以我們得選擇要讓組譯器用那種 bit mode 來翻譯出 machine code, 這個例子是 16 bit (ref address_mode.S L2, L3)。</p>
<p>03 07 是 machine code, 對應到 opcode modrm 這兩欄, 沒有 prefix, displacement, immediate 這些部份。</p>
<p>來看看 add 的 opcode:</p>
<p><a href="http://css.csail.mit.edu/6.858/2011/readings/i386/ADD.htm">http://css.csail.mit.edu/6.858/2011/readings/i386/ADD.htm</a></p>
<p>有好幾個, 看以下這個:</p>
<pre><code>03 /r     ADD r16,r/m16        2/6      Add r/m word to word register
clock 那欄我看不懂, 有請大大解惑。
所以 03 是 opcode, 03 搞定, 那 07 是什麼?

07 是 modrm 這欄, 再細分解為 2:3:3 欄位,
0000 0111 -&gt; 00 000 111
mod: 00
reg: 000
r/m: 111</code></pre>
<p>把 mod, r/m 拿來查表。</p>
<p>mod = 00 時的對照表 (16 bit)</p>
<table>
<thead>
<tr class="header">
<th align="left">Effective Address</th>
<th align="left">r/m</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">[BX+SI]</td>
<td align="left">000</td>
</tr>
<tr class="even">
<td align="left">[BX+DI]</td>
<td align="left">001</td>
</tr>
<tr class="odd">
<td align="left">[BP+SI]</td>
<td align="left">010</td>
</tr>
<tr class="even">
<td align="left">[BP+DI]</td>
<td align="left">011</td>
</tr>
<tr class="odd">
<td align="left">[SI]</td>
<td align="left">100</td>
</tr>
<tr class="even">
<td align="left">[DI]</td>
<td align="left">101</td>
</tr>
<tr class="odd">
<td align="left">disp16</td>
<td align="left">110</td>
</tr>
<tr class="even">
<td align="left">[BX]</td>
<td align="left">111</td>
</tr>
</tbody>
</table>
<p>得到 [BX], 這是 base register address mode</p>
<p>reg: 000 代表 ax register</p>
<p>register table</p>
<table>
<thead>
<tr class="header">
<th align="left">REG</th>
<th align="left">Register</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">000</td>
<td align="left">EAX/AX</td>
</tr>
<tr class="even">
<td align="left">001</td>
<td align="left">ECX/CX</td>
</tr>
<tr class="odd">
<td align="left">010</td>
<td align="left">EDX/DX</td>
</tr>
<tr class="even">
<td align="left">011</td>
<td align="left">EBX/BX</td>
</tr>
<tr class="odd">
<td align="left">100</td>
<td align="left">ESP/SP</td>
</tr>
<tr class="even">
<td align="left">101</td>
<td align="left">EBP/BP</td>
</tr>
<tr class="odd">
<td align="left">110</td>
<td align="left">ESI/SI</td>
</tr>
<tr class="even">
<td align="left">111</td>
<td align="left">EDI/DI</td>
</tr>
</tbody>
</table>
<p>得到 add ax, [bx] (intel syntax), 恭喜, 終於看懂 machine code 了。但是要從 add ax, [bx] 得到 03 07 就比較難了。</p>
<p>這在 intel 術語稱為: one-byte address mode encoding。</p>
<p>這篇好像有點長了, 不過打鐵趁熱, 來看看 prefix 的例子。</p>
<p>檔案：address_mode1.S</p>
<pre><code>1 # practice x86 machine code
2 .code16
3 #.code32
4 .text
5 .global begin
6 begin:
7   add (%bx), %eax</code></pre>
<p>和 address_mode.S 的差別僅在 %eax, %ax 改成 %eax。我一直被 16 bit 程式碼可以使用 32 bit register 所疑惑, 這樣的程式碼倒底是 16 bit 還是 32 bit? 當然是 16 bit, 那你和我覺得疑惑可以使用 32 bit register 嗎？讓我們透過 prefix 解除這疑惑。</p>
<pre><code>objdump -d -m i8086 address_mode.elf

1 descent@w-linux:x86_machine_code$ objdump -d -m i8086 address_mode.elf 
2 
3 address_mode.elf:     file format elf32-i386
4 
5 
6 Disassembly of section .text:
7 
8 00000100 &lt;_text&gt;:
9  100:   66 03 07                   add    (%bx),%eax</code></pre>
<p>machine code 則多了一個 66, 這就是 prefix, 用來切換 operand size, 這裡的例子是從 16 bit 切換成 32 bit, 本程式執行在 16 bit 下, 而 %eax 是 32 bit operand, 所以要加上 prefix 0x66, 就這麼簡單。</p>
<h3 id="想想看"><a href="#想想看">想想看:</a></h3>
<p>什麼是 32 bit 執行環境? A: ...</p>
<p>若在 32 bit 執行環境執行這個 machine code 又是什麼意思？</p>
<p>A:</p>
<pre><code>.code32
.text
.global begin
begin:
  add (%edi), %ax</code></pre>
<p>很有意思吧, x86 就是這麼討厭又讓人喜愛。</p>
<p>好用的組譯器: <a href="http://radare.org/y/?p=examples&amp;f=rasm">http://radare.org/y/?p=examples&amp;f=rasm</a> ，玩 machine code 的朋友一定要試試。</p>
<h3 id="參考文獻"><a href="#參考文獻">參考文獻</a></h3>
<ol style="list-style-type: decimal">
<li>x86/x64 指令编码内幕（适用于 AMD/Intel）: <a href="http://www.mouseos.com/x64/index.html">http://www.mouseos.com/x64/index.html</a></li>
<li>学习 OpCode: <a href="http://www.luocong.com/learningopcode.htm">http://www.luocong.com/learningopcode.htm</a></li>
<li>Programming THE 80386</li>
<li><a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a></li>
</ol>
<p>【本文原文網址為： <a href="http://descent-incoming.blogspot.tw/2013/06/x86-machine-code-0-base-register.html">http://descent-incoming.blogspot.tw/2013/06/x86-machine-code-0-base-register.html</a> ，由陳鍾誠編輯後納入本雜誌】</p>
</div>
<div id="footer">
<a href="https://www.facebook.com/groups/programmerMagazine/">程式人雜誌</a> ，採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/ ">創作共用：姓名標示、相同方式分享</a> 授權，歡迎加入 <a href="https://www.facebook.com/groups/programmerMagazine/">雜誌社團</a>
</div>
</body>
</html>
